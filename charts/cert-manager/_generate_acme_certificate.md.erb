<%
=begin
apps: cert-manager
platforms: kubernetes
id: generate_acme_certificate
title: Generate certificate signing with ACME
category: configuration
weight: 40
highlight: 40
=end %>

Cert Manager allow to sign certificates with different ways. One of this ways is to use ACME (Automated Certificate Management Environment).
Cert Manager provide us the support for configuring a Issuer that represents a single account registered inside ACME Certificate Authority server.
Cert Manager will generate a private key which is used to identify you in the ACME Server.

In order to verify that a client owns the domain, Cert Manager uses challenges. This is a secure way to verify that the domain that you are setting up
in your Issuer is yours. Cert Manager have two different challenges to verify that you are the proprietary of your domain HTTP01 or DNS01, more information [here](https://cert-manager.io/docs/concepts/acme-orders-challenges/#challenge-scheduling).

To create a ACME issuer to generate the certificate using let's encrypt, we need to declare an Issuer:

- Issuer

~~~
apiVersion: cert-manager.io/v1alpha2
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    # You must replace this email address with your own.
    # Let's Encrypt will use this to contact you about expiring
    # certificates, and issues related to your account.
    email: bn_certmanager@bitnami.com
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: letsencrypt-prod
    # Add a single challenge solver, HTTP01 using nginx
    solvers:
    - http01:
        ingress:
          class: nginx
~~~

To use the ClusterIssuers inside our ingress, take a look the section "Create or configure an ingress using Cert Manager").

Wait until the Ingress is ready (this example follows the own ingress configuration). Then, Cert Manager will begin to verify using HTTP01 that you are the proprietary of your own domain. During this verification, you can log the controller to see the process and the status. Moreover, if you list the certificates:

~~~
$ k get certificates
NAME                     READY   SECRET                   AGE
letencrypt-ca            False   letencrypt-ca             X
~~~

You will see that the ready status is False. This status will change to True when the HTTP01 verification is succesfully and over.

~~~
$ k get certificates
NAME                     READY   SECRET                   AGE
letencrypt-ca            True    letencrypt-ca             X

$ k get secrets
NAME                                  TYPE                                  DATA   AGE
letencrypt-ca                      kubernetes.io/tls                        3      Xm
~~~
