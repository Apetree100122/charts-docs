<%
=begin
apps: wordpress
platforms: kubernetes
id: configure_use_ingress
title: Configure and use Ingress with WordPress
category: configuration
weight: 20
highlight: 20
=end %>

This chart supports Ingress resources. If an Ingress controller, such as [nginx-ingress](https://hub.kubeapps.com/charts/stable/nginx-ingress) or [traefik](https://hub.kubeapps.com/charts/stable/traefik), is installed in the cluster, that Ingress controller can be used to serve WordPress.

To enable Ingress integration, set the *ingress.enabled* parameter to *true*.

### Hosts

The most typical scenario is to have one host name mapped to the WordPress deployment. In this case, the *ingress.hostname* property can be used to set the host name.

However, it is also possible to have more than one host. To facilitate this, the *ingress.extraHosts* object can be set, with the host names specified as an array. The *ingress.extraTLS* parameter can also be used to add the TLS configuration for extra hosts.

> NOTE: For each host specified in the *ingress.extraHosts* parameter, it is necessary to set a name, path, and any annotations that the Ingress controller should know about. Not all annotations are supported by all Ingress controllers, but [this annotation reference document](https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md) lists the annotations supported by many popular Ingress controllers.

Adding the TLS parameter will cause WordPress to generate HTTPS URLs, and the WordPress application will be available on port 443. The actual TLS secrets do not have to be generated by this chart. However, if TLS is enabled, the Ingress record will not work until the TLS secret exists.

### TLS Secrets

This chart facilitates the creation of TLS secrets for use with the Ingress controller. There are three common use cases:

* Helm generates/manages certificate secrets
* User generates/manages certificates separately
* An additional tool (like *kube-lego*) manages the secrets for the application

In the first two cases, a certificate and a key are required.

* Certificate files should look like this (and there can be more than one certificate if there is a certificate chain):

~~~
-----BEGIN CERTIFICATE-----
MIID6TCCAtGgAwIBAgIJAIaCwivkeB5EMA0GCSqGSIb3DQEBCwUAMFYxCzAJBgNV
...
jScrvkiBO65F46KioCL9h5tDvomdU1aqpI/CBzhvZn1c0ZTf87tGQR8NK7v7
-----END CERTIFICATE-----
~~~

* Keys should look like this:

~~~
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAvLYcyu8f3skuRyUgeeNpeDvYBCDcgq+LsWap6zbX5f8oLqp4
...
wrj2wDbCDCFmfqnSJ+dKI3vFLlEz44sAV8jX/kd4Y6ZTQhlLbYc=
-----END RSA PRIVATE KEY-----
~~~

If using Helm to manage the certificates, copy these values into the *certificate* and *key* values for a given *ingress.secrets* entry.

If managing TLS secrets outside Helm, create a TLS secret separately and [refer to the Kubernetes TLS documentation](https://github.com/kubernetes/contrib/tree/master/ingress/controllers/nginx/examples/tls) for more information.

### Ingress-terminated HTTPS

In cases where HTTPS/TLS is terminated on the Ingress controller, you may run into an issue where non-HTTPS liveness and readiness probes result in a 302 (redirect from HTTP to HTTPS) and are interpreted by Kubernetes as not-live/not-ready ([Kubernetes issue #47893 on GitHub has more details](https://github.com/kubernetes/kubernetes/issues/47893)).

To work around this problem, use the *livenessProbeHeaders* and *readinessProbeHeaders* parameters to pass the same headers that the Ingress controller would pass in order to get an HTTP 200 status result. Refer to the example below, which shows the relevant configuration in a *--values-referenced* file:

~~~
livenessProbeHeaders:
  - name: X-Forwarded-Proto
    value: https
readinessProbeHeaders:
  - name: X-Forwarded-Proto
    value: https
~~~

Any number of name/value pairs may be specified; they are all copied into the liveness or readiness probe definition.